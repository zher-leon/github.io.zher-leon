### 函数参数名问题

​	通常我们定义一个函数类型，可以这么写：

```typescript
type Func = (content: string) => void

const testFunc: Func = function (content) {
  console.log('content', content)
}
```

​	这里我们下意识会认为，函数类型里的参数名和实际的参数名，是一一对应的，其实不是的。

```typescript
type Func = (x: number) => number

const testFunc: Func = function(y) {
	return y + 10
}
```

​	这个例子中的函数实际参数名是y，但是类型定义里面写x，这种写法也是完全可行的，这样就可以方便我们在**函数类型很冗长或者多个函数使用同一种类型**的情况下使用。

### 函数的参数数量

​	另外，**函数的实际参数的个数，可以少于类型指定的参数个数，但不能多于**。

```typescript
type Func = (x: number, y: number) => number

// ok
const funcA: Func = (a) => a + 1
// ok
const funcB: Func = (a, b) => a + b

// error!! 
const funcC: Func = (a, b, c) => a + b * c
```

### 使用typeof 获取函数类型	

​	还有一个小技巧，就是使用`typeof`运算符，来获取函数的类型。

```typescript
const add = (x: number, y: number): number => x + y

const myAdd: typeof add = (x, y) => x + 2 * y
```

### 以对象的方式声明函数类型

​	这是一个我感觉比较小众的函数写法，这种写法我个人认为不是很直观：

```typescript
type Func = {
	(x: number, y: number): number
}

const add: Func = (x, y) => x + y

/**
	大概的格式就是：
	{
		(参数列表): 返回值
	}
**/
```

### Function 类型

​	对于函数的类型，TS提供了`Function`来表示，只要是个函数，它都属于这个类型。一个变量的类型声明是Function的话，意思就是这是个函数，它有不定数量的参数，每个参数的类型都是any，而且返回值也是any，没有任何约束，只是认为只是个可执行函数。这样写过于笼统，还是像上述例子那样给出详细的声明比较好。

### void 类型

​	如果我们声明的函数类型没有返回值，可以用`void`表示。

```typescript
const x = (a: number): void => {
	console.log('hello', a)
}
```

​	这里有一个有点刁钻的点，就是正常来说，返回值为void，这个时候函数里返回了值(除了`null`和`undefined`)，是会报错的。但是，当一个变量、对象方法、函数参数是一个返回值为void类型的函数，那就可以接受返回任意值的函数，这个时候不会报错。

```typescript
const funcA = (a: number): void => {
	return a // 不能将类型"number"分配给类型"void"
}

const funcB: (a: number) => void = (a) => {
	return a // it's ok
}
```

​	这是因为TS认为上述FuncB这种写法的void类型表示这个函数的返回值没有利用价值，或者说不应该使用该函数的返回值，只要不用到这个函数的返回值，就不会报错。

```typescript
// 如果在funcB这种情况下使用了它的返回值, 依然会报错，理由如上所述。
console.log(funcB() * 2)
```

### never 类型

​	`never`表示肯定不会出现的值，它用在函数的返回值，就表示这个函数肯定不会返回值，即函数不会正常执行结束。主要有两种情况会用到：

```typescript
// 第一种，抛出错误的函数，要注意是抛出错误，而不是返回一个错误，如果是返回的话，它的返回值类型应该是Error对象
function fail(msg: string): never {
  throw new Error(msg)
}

// 第二种，无限执行的函数
function sing(): never {
  while(true) {
    console.log('lalala')
  }
}
```

​	需要注意的是，如果某个函数存在正常的返回值，它的返回值还要要写正常的返回值的类型，因为`never`是 TS 的唯一一个底层类型，所有其他类型都包括了`never`，所以说，`number|never`等同于`number`，函数值的返回值无论是什么类型，都可能包含了抛出错误的情况。

```typescript
function test(x: number): number {
  if (x < 0) {
    throw new Error('抛出个异常')
  }

  return x / 2
}
```

### 高阶函数

​	高阶函数常见的两种形式：

```typescript
// 第一种，一个函数返回值还是一个函数，类似这种，将多参数的函数转化为单个参数的函数链的过程，我们也叫它函数柯里化
const funcA = (a: number) => (b: number) => a * b

// 第二种，一个函数的有一个或多个参数是一个函数
const do = (type: Function, a: number, b: number) => return type(a, b)
const add = (a, b) => a + b
do(add, 3, 5) // 8
```

### 函数重载

​	有些函数可以接受不同类型或不同个数的参数，并且根据参数的不同，会有不同的函数行为，这种行为叫做函数重载。TS对于函数重载的类型声明方法是，逐一定义每种情况的类型。

```typescript
// 这两行是函数类型声明
function reverse(str: string): string;
function reverse(arr: any[]): any[];
// 这里是函数实现
function reverse(param: string | any[]): string | any[] {
	if (typeof param === 'string') {
		return param.split('').reverse().join('')
	} else {
		return param.slice().reverse()
	}
}
```

​	**需要特别注意的是：**

- 重载的各个类型描述与函数的具体实现之间，不能有其他代码，否则会报错！！

- 重载声明顺序很重要，一定要把范围最宽的放在最下面，因为TS是按照顺序进行检查的，一旦发现复合某个类型声明就不再往下检查了。